;;;; ==========================================================================
;;;; @title Ether Multisend
;;;; @author Noel Maersk <veox>

;;;; In a transient program, both code and data must be passed in the same
;;;; transaction field (CALLDATA).
;;;;
;;;; Execution starts from the beginning of CALLDATA, so code _must_ come
;;;; first, especially since data can vary in size.
;;;;
;;;; Data size checks have been removed for simplicity's sake; so has been
;;;; the use of 4-byte function selectors, and array formatting.
;;;;
;;;; CALLDATA is intended to look as follows:
;;;;
;;;; CODE    | Nrcpnt | <(to,amt), (to,amt), ...>
;;;; (256 B) | (32 B) | (32+32 B) * Ntgt
;;;;
;;;; where:
;;;;
;;;; CODE: compiled code (below), padded to a fixed size
;;;; Nrcpnt: number of recipients (i.e. array size for both `_to[]` and `_amt[]`)
;;;; (to,amt): recipient address and amount

(seq
  (include "./common.lll.inc")

  ;; ==========================================================================
  ;; MEMORY LAYOUT

  (def '*memloc-counter* 0x60)

  ;; ==========================================================================
  ;; CONSTANTS

  (def '*cd-dataoffset*  96)     ; compiled program will fit in first N bytes
  (def '*cd-Rdataoffset* 128)    ; UGLY: (+ *cd-dataoffset* 32) shortcut
  (def '*gaslim*         30000)  ; gas limit for each nested call

  ;; ==========================================================================
  ;; INIT

  ;; none!

  ;; ==========================================================================
  ;; CODE

  (seq
    ;; *cd-dataoffset* will contain the number of recipients
    (mstore *memloc-counter* (calldataload *cd-dataoffset*))

    ;; LOOP through "array of tuples" in reverse
    (while
        (mload *memloc-counter*) ;; last processed array member is not 0th
      (seq
        ;; calculate offset of current (to,amt) element from start of data
        ;; NOTE use of Rdataoffset instead of simple dataoffset; for some
        ;; reason the optimiser doesn't pick up on this, preventing the
        ;; fitting of this program into 64 bytes :/
        (mstore *memloc-scratchpad* (+ *cd-Rdataoffset*
                                       (* (mload *memloc-counter*) 0x20)))

        (unless (send *gaslim*
                      ;; to
                      (calldataload (mload *memloc-scratchpad*))
                      ;; amt
                      (calldataload (+ (mload *memloc-scratchpad*) 0x20)))
          ;; TODO: don't fail; bounce balance back instead
          (revert 0 0))

        ;; decrement counter
        (mstore *memloc-counter* (- (mload *memloc-counter*) 1))))
    (return 0 0)))
