;;;; ==========================================================================
;;;; @title Ether Multisend
;;;; @author Noel Maersk <veox>

;;;; In a transient program, both code and data must be passed in the same
;;;; transaction field (CALLDATA).
;;;;
;;;; Execution starts from the beginning of CALLDATA, so code _must_ come
;;;; first, especially since data can vary in size.
;;;;
;;;; Data size checks have been removed for simplicity's sake; so has been
;;;; the use of 4-byte function selectors, and array formatting.
;;;;
;;;; CALLDATA is intended to look as follows:
;;;;
;;;; CODE    | Nrcpnt | <(to,amt), (to,amt), ...>
;;;; (256 B) | (32 B) | (32+32 B) * Ntgt
;;;;
;;;; where:
;;;;
;;;; CODE: compiled code (below), padded to a fixed size
;;;; Nrcpnt: number of recipients (i.e. array size for both `_to[]` and `_amt[]`)
;;;; (to,amt): recipient address and amount

(seq
  (include "./common.lll.inc")

  ;; ==========================================================================
  ;; MEMORY LAYOUT

  (def '*memloc-counter* 0x60)
  (def '*memloc-to*      0x80)
  (def '*memloc-amt*     0xa0)

  ;; ==========================================================================
  ;; CONSTANTS

  (def '*gaslim*         30000)  ; gas limit for each nested call

  ;; ==========================================================================
  ;; INIT

  ;; none!

  ;; ==========================================================================
  ;; CODE

  (seq
    ;; first word after (bytecodesize) is number of elements - use as counter
    (codecopy *memloc-counter* (bytecodesize) 0x20)

    ;; LOOP through "array of tuples" in reverse
    (while
        (mload *memloc-counter*) ;; last processed array member is not 0th
      (seq
        ;; calculate offset of current (to,amt) element from start of data
        ;; NOTE: first word after (bytecodesize) is number of elements, so skip
        (mstore *memloc-scratchpad* (+ (+ (bytecodesize) 0x20)
                                       (* (mload *memloc-counter*) 0x20)))

        (codecopy *memloc-to*     (mload *memloc-scratchpad*)       0x20)
        (codecopy *memloc-amt* (+ (mload *memloc-scratchpad*) 0x20) 0x20)

        (unless (send *gaslim*
                      ;; to
                      (mload *memloc-to*)
                      ;; amt
                      (mload *memloc-amt*))
          ;; TODO: don't fail; bounce balance back instead
          (revert 0 0))

        ;; decrement counter
        (mstore *memloc-counter* (- (mload *memloc-counter*) 1))))
    (return 0 0)))
